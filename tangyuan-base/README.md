
===================================================================

服务的定义：

1. 服务是独立的，每个服务都有自己的上下文，不存在继承直说（RPC调用无法实现），避免服务的耦合性
2. 所有服务，不抛出异常

===================================================================
事务的定义：
1. 仅限SQL部分
2. 可以手工开启事务
3. 提供SQL.execute方法，以SQL命令的方式执行
4. 事务的处理
	4.1 提交
	4.2 回滚
	4.3 异常



===================================================================

1. 整合manager模块:客户端
2. 重构3.0(可简化)
3. manager服务端

===================================================================

1. 整理 ManagerLauncher					OK
2. 整理 LocalStorage						OK
3. 整理 日志								running
5. 然后 每个类都可以整理日志了
4. 整理 http								OK

6. 整理 RuntimeContext
7. 整理 PropertyUtils
8. 整理 XMLUtils							OK
9. 整理 ResourceReloader					OK

10. callback机制
	由于有启动顺序的问题，需要增加统一的callback机制，通过回调，来进行对象的传入

11. 属性对时间单位的支持
	10s, 10m, 10d, 10h

5. yam

12. xml每个服务增一个属性desc,用于服务的描述
	每个方法上增加一个注释，用于服务的描述

13. xml支持命名空间

14. manager 配置文件需要生命使用的client客户端ID

15. rpc嵌入核心包

16. 数据转换，是否考虑最后一层进行转换

17. 整理SQL组件

18. 缓存，考虑排除，字段，空值

19. 服务内嵌

20. 支持druid


21. 重新涉及reloader接口和机制 ***
	资源文件全部，先保存本地，在从本地加载

22. 服务分层处理
	1. 验证, 2. 权限, 3: runtime, 4:aop
	

服务的层级划分
1. 上下文
2. 监控(Runtime)
3. 状态-判断
4. 参数转换
5. aop
6. service


Actuator中的参数，不能变

cache
1. 排除忽略的字段
2. 空对象的处理


ActuatorImpl中取消ignoreWrapper属性，之留给外层的包装类Actuator，做方便用户的功能



Actuator中的参数，不能变

runtime和arg
===========================================================
内部服务调用
	新服务：应用状态判断-->服务状态判断
	执行中：直接调用(最后时间判断)
外部服务调用
	防火墙-->应用状态判断-->服务状态判断
	
关闭问题

// 在commit阶段发生异常，则执行期间获取的result是无意义的****
// 这还涉及到缓存

===================================================================
Runtime和trace 不是一体的，trace依赖runtime
Runtime和trace剥离

===================================================================

1. manager服务端设计

资源加载流程
1. 



Runtime和trace 不是一体的，trace依赖runtime
Runtime和trace剥离

1. runtime include trace

2. trace include runtime

log:
	根据组件进行过滤，意义不大，而且准确性不明确

runtime:
	1. 承载请求进入系统后的头部信息数据
	2. 承载系统相关的信息，如nodeName, appName等
	3. ////
	
trace:
	1. 服务跟踪

1. arg不承载参数
2. temp承载参数
3. aop可以手工的修改arg
4. aop需要引入上下文的概念
5. aop也可以完全交由java处理
6. 缓存的处理需要放在提交之后
7. arg不可变（系统不可默认的去改变），可以手工的边，比如aop



## 对于事物的优化
1. 检查是否开启新连接
2. 检查


服务调用服务:
服务调用方法：

服务之间是隔离的，
	1. 服务之间的事物是不应该由关系的
	2. 服务之间的上下文，也不应该有关系
服务可以调用方法

服务创建上下文，SQL事物基于上下文，

什么是服务
服务中一定允许其他调用服务

对于SQL中
1. 服务
2. SQL语句

	sql-command,			A:不需要指定事物，或者使用编程式的事物
	selectSet-command
	selectOne-command
	selectVar-command
	update-command
	delete-command
	insert-command
	sql-command 			B:支持多条sql语句
		
	Sql.execute(ID);			//默认匹配的事物
	Sql.execute(ID, 事物);		//手工指定事物
	
	SQL.execute(ID);			//默认匹配的事物
	SQL.execute(ID, 事物);		//手工指定事物
	
编程式事物(CODE) && 声明式事物(AOP)


1. SQL调用的对服务的影响
2. 服务的独立性的保证***
3. SQL调用存在的意义？
	1. 复杂的服务实现，需要JAVA+SQL/MONGO;
	2. 
4. 

服务之间不能传递事物；

那 事物如何传递呢？

	通过sql.trans，那SQL如何定义呢？
	
	1.　通过现有的SQL服务标签：
		1. 会存在标签的二义性	*** 选择此方案,服务的细粒度不可回避；
			1. 满足服务定义的原始性；
			2. 满足单独使用性；
			3. 延续之前的设定；
			
	2.	通过新的标签定义：
		1. XML中定义出现插件的二义性，既可以定义服务，又可以定义SQL语句 ***
		2. 标签过多 *
		3. 对现有标签的影响，比如sql-service中的内部标签
	
	3.  是否还有新的方案，是否可以折中？
		我们以服务为维度，把所需的SQL语句进行打包，只能允许一个服务调用；
		作为一个服务的组成部分，那就类似java服务的方法，
		也就意味着力度的问题；
		
	
================================================
异步服务增加callback：
	callback：可以是服务，必须是服务；

================================================
服务的统一调用问题：变化大，
	只保留ActuatorImpl中的execute和executeAsync,execute=executeAlone
	
================================================
AOP:可以是一个服务，也可以是本地的JAVA类，具体的AOP接口，分前置和后置

================================================
JAVA支持TCC事物：

================================================
日志中特定字段的加密：基于服务和上下文进行控制；

================================================
参数原则:
	1. 对于服务的入参，执行期间不能改变
	2. 关于AOP对于参数的影响
	
参数在什么时候克隆？
	1. 需要在统一的时间?
	2. 
	
	
	
SQL-COMMAND的异常如何处理--统一上抛
	
================================================
xco toJSON 需要处理\n-->x = x.replaceAll("\n", "\\\\n");